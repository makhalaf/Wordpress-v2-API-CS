/*
 * WordpressV2API.PCL
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io )
 */
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json.Converters;
using WordpressV2API.PCL;
using WordpressV2API.PCL.Utilities;
using WordpressV2API.PCL.Http.Request;
using WordpressV2API.PCL.Http.Response;
using WordpressV2API.PCL.Http.Client;
using WordpressV2API.PCL.Exceptions;
using WordpressV2API.PCL.Models;

namespace WordpressV2API.PCL.Controllers
{
    public partial class APIController: BaseController
    {
        #region Singleton Pattern

        //private static variables for the singleton pattern
        private static object syncObject = new object();
        private static APIController instance = null;

        /// <summary>
        /// Singleton pattern implementation
        /// </summary>
        internal static APIController Instance
        {
            get
            {
                lock (syncObject)
                {
                    if (null == instance)
                    {
                        instance = new APIController();
                    }
                }
                return instance;
            }
        }

        #endregion Singleton Pattern

        /// <summary>
        /// List Status
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Status3> response from the API call</return>
        public List<Models.Status3> GetStatuses(Models.ContextEnum? context = null)
        {
            Task<List<Models.Status3>> t = GetStatusesAsync(context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Status
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Status3> response from the API call</return>
        public async Task<List<Models.Status3>> GetStatusesAsync(Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/statuses");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Status3>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Type
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Type> response from the API call</return>
        public List<Models.Type> GetTypes(Models.ContextEnum? context = null)
        {
            Task<List<Models.Type>> t = GetTypesAsync(context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Type
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Type> response from the API call</return>
        public async Task<List<Models.Type>> GetTypesAsync(Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/types");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Type>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public Models.Post GetPostsById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Post> t = GetPostsByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public async Task<Models.Post> GetPostsByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Post>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Revision> response from the API call</return>
        public List<Models.Revision> GetPostsRevisionsById(string id, Models.ContextEnum? context = null)
        {
            Task<List<Models.Revision>> t = GetPostsRevisionsByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the List<Models.Revision> response from the API call</return>
        public async Task<List<Models.Revision>> GetPostsRevisionsByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}/revisions");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Revision>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeletePostsById(string id, bool? force = null)
        {
            Task t = DeletePostsByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeletePostsByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Delete single post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="revisionid">Required parameter: Id of revision</param>
        /// <return>Returns the void response from the API call</return>
        public void DeletePostsRevisionsByIdAndRevisionid(string id, string revisionid)
        {
            Task t = DeletePostsRevisionsByIdAndRevisionidAsync(id, revisionid);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete single post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="revisionid">Required parameter: Id of revision</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeletePostsRevisionsByIdAndRevisionidAsync(string id, string revisionid)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}/revisions/{revisionid}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id },
                { "revisionid", revisionid }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get single post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="revisionid">Required parameter: Id of revision</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Revision response from the API call</return>
        public Models.Revision GetPostsRevisionsByIdAndRevisionid(string id, string revisionid, Models.ContextEnum? context = null)
        {
            Task<Models.Revision> t = GetPostsRevisionsByIdAndRevisionidAsync(id, revisionid, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get single post revisions
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="revisionid">Required parameter: Id of revision</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Revision response from the API call</return>
        public async Task<Models.Revision> GetPostsRevisionsByIdAndRevisionidAsync(string id, string revisionid, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}/revisions/{revisionid}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id },
                { "revisionid", revisionid }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Revision>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public Models.Category GetCategoriesById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Category> t = GetCategoriesByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public async Task<Models.Category> GetCategoriesByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/categories/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Category>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Category
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public Models.Category CreateCategories(
                string name,
                string description = null,
                string slug = null,
                int? parent = null)
        {
            Task<Models.Category> t = CreateCategoriesAsync(name, description, slug, parent);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Category
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public async Task<Models.Category> CreateCategoriesAsync(
                string name,
                string description = null,
                string slug = null,
                int? parent = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/categories");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "description", description },
                { "slug", slug },
                { "parent", parent }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Category>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Taxonomy
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Taxonomy response from the API call</return>
        public Models.Taxonomy GetTaxonomiesById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Taxonomy> t = GetTaxonomiesByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Taxonomy
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Taxonomy response from the API call</return>
        public async Task<Models.Taxonomy> GetTaxonomiesByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/taxonomies/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Taxonomy>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Taxonomy
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="type">Optional parameter: Limit result set to comments assigned a specific type. Requires authorization. Default comment</param>
        /// <return>Returns the List<Models.Taxonomy> response from the API call</return>
        public List<Models.Taxonomy> GetTaxonomies(Models.ContextEnum? context = null, string type = null)
        {
            Task<List<Models.Taxonomy>> t = GetTaxonomiesAsync(context, type);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Taxonomy
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="type">Optional parameter: Limit result set to comments assigned a specific type. Requires authorization. Default comment</param>
        /// <return>Returns the List<Models.Taxonomy> response from the API call</return>
        public async Task<List<Models.Taxonomy>> GetTaxonomiesAsync(Models.ContextEnum? context = null, string type = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/taxonomies");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "type", type }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Taxonomy>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteCommentsById(string id, bool? force = null)
        {
            Task t = DeleteCommentsByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteCommentsByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/comments/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public Models.Comment GetCommentsById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Comment> t = GetCommentsByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public async Task<Models.Comment> GetCommentsByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/comments/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Comment>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Status
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Status3 response from the API call</return>
        public Models.Status3 GetStatusesById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Status3> t = GetStatusesByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Status
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Status3 response from the API call</return>
        public async Task<Models.Status3> GetStatusesByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/statuses/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Status3>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Type
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Type response from the API call</return>
        public Models.Type GetTypesById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Type> t = GetTypesByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Type
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Type response from the API call</return>
        public async Task<Models.Type> GetTypesByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/types/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Type>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteMediaById(string id, bool? force = null)
        {
            Task t = DeleteMediaByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteMediaByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/media/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public Models.Media GetMediaById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Media> t = GetMediaByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public async Task<Models.Media> GetMediaByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/media/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Media>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeletePagesById(string id, bool? force = null)
        {
            Task t = DeletePagesByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeletePagesByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/pages/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public Models.Page GetPagesById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Page> t = GetPagesByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public async Task<Models.Page> GetPagesByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/pages/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Page>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <param name="reassign">Optional parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteUsersById(string id, bool? force = null, string reassign = null)
        {
            Task t = DeleteUsersByIdAsync(id, force, reassign);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <param name="reassign">Optional parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteUsersByIdAsync(string id, bool? force = null, string reassign = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/users/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "reassign", reassign }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public Models.User GetUsersById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.User> t = GetUsersByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public async Task<Models.User> GetUsersByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/users/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.User>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteTagsById(string id, bool? force = null)
        {
            Task t = DeleteTagsByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteTagsByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/tags/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Update Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public Models.Tag CreateTagsById(
                string id,
                string name,
                string description = null,
                string slug = null)
        {
            Task<Models.Tag> t = CreateTagsByIdAsync(id, name, description, slug);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public async Task<Models.Tag> CreateTagsByIdAsync(
                string id,
                string name,
                string description = null,
                string slug = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/tags/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "description", description },
                { "slug", slug }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Tag>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public Models.Tag GetTagsById(string id, Models.ContextEnum? context = null)
        {
            Task<Models.Tag> t = GetTagsByIdAsync(id, context);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get Single Tag
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public async Task<Models.Tag> GetTagsByIdAsync(string id, Models.ContextEnum? context = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/tags/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Tag>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Tag
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public Models.Tag CreateTags(string name, string description = null, string slug = null)
        {
            Task<Models.Tag> t = CreateTagsAsync(name, description, slug);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Tag
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the Models.Tag response from the API call</return>
        public async Task<Models.Tag> CreateTagsAsync(string name, string description = null, string slug = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/tags");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "description", description },
                { "slug", slug }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Tag>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteCategoriesById(string id, bool? force = null)
        {
            Task t = DeleteCategoriesByIdAsync(id, force);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="force">Optional parameter: Whether to bypass trash and force deletion.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteCategoriesByIdAsync(string id, bool? force = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/categories/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "force", force }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Update Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public Models.Category CreateCategoriesById(
                string id,
                string name,
                string description = null,
                string slug = null,
                int? parent = null)
        {
            Task<Models.Category> t = CreateCategoriesByIdAsync(id, name, description, slug, parent);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Category
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <return>Returns the Models.Category response from the API call</return>
        public async Task<Models.Category> CreateCategoriesByIdAsync(
                string id,
                string name,
                string description = null,
                string slug = null,
                int? parent = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/categories/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "description", description },
                { "slug", slug },
                { "parent", parent }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Category>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="username">Optional parameter: The user name for the resource.</param>
        /// <param name="firstName">Optional parameter: The first name for the resource.</param>
        /// <param name="lastName">Optional parameter: The last name for the resource.</param>
        /// <param name="email">Optional parameter: Email of the resource.</param>
        /// <param name="url">Optional parameter: URL of the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="nickname">Optional parameter: The nickname for the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="capabilities">Optional parameter: All capabilities used by the resource.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public Models.User CreateUsersById(
                string id,
                string name,
                string username = null,
                string firstName = null,
                string lastName = null,
                string email = null,
                string url = null,
                string description = null,
                string nickname = null,
                string slug = null,
                List<string> roles = null,
                string password = null,
                List<string> capabilities = null)
        {
            Task<Models.User> t = CreateUsersByIdAsync(id, name, username, firstName, lastName, email, url, description, nickname, slug, roles, password, capabilities);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single User
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="username">Optional parameter: The user name for the resource.</param>
        /// <param name="firstName">Optional parameter: The first name for the resource.</param>
        /// <param name="lastName">Optional parameter: The last name for the resource.</param>
        /// <param name="email">Optional parameter: Email of the resource.</param>
        /// <param name="url">Optional parameter: URL of the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="nickname">Optional parameter: The nickname for the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="capabilities">Optional parameter: All capabilities used by the resource.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public async Task<Models.User> CreateUsersByIdAsync(
                string id,
                string name,
                string username = null,
                string firstName = null,
                string lastName = null,
                string email = null,
                string url = null,
                string description = null,
                string nickname = null,
                string slug = null,
                List<string> roles = null,
                string password = null,
                List<string> capabilities = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/users/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "username", username },
                { "first_name", firstName },
                { "last_name", lastName },
                { "email", email },
                { "url", url },
                { "description", description },
                { "nickname", nickname },
                { "slug", slug },
                { "password", password }
            };
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("roles", roles));
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("capabilities", capabilities));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.User>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create User
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="username">Optional parameter: The user name for the resource.</param>
        /// <param name="firstName">Optional parameter: The first name for the resource.</param>
        /// <param name="lastName">Optional parameter: The last name for the resource.</param>
        /// <param name="email">Optional parameter: Email of the resource.</param>
        /// <param name="url">Optional parameter: URL of the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="nickname">Optional parameter: The nickname for the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="capabilities">Optional parameter: All capabilities used by the resource.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public Models.User CreateUsers(
                string name,
                string username = null,
                string firstName = null,
                string lastName = null,
                string email = null,
                string url = null,
                string description = null,
                string nickname = null,
                string slug = null,
                List<string> roles = null,
                string password = null,
                List<string> capabilities = null)
        {
            Task<Models.User> t = CreateUsersAsync(name, username, firstName, lastName, email, url, description, nickname, slug, roles, password, capabilities);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create User
        /// </summary>
        /// <param name="name">Required parameter: HTML title for the resource.</param>
        /// <param name="username">Optional parameter: The user name for the resource.</param>
        /// <param name="firstName">Optional parameter: The first name for the resource.</param>
        /// <param name="lastName">Optional parameter: The last name for the resource.</param>
        /// <param name="email">Optional parameter: Email of the resource.</param>
        /// <param name="url">Optional parameter: URL of the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="nickname">Optional parameter: The nickname for the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="capabilities">Optional parameter: All capabilities used by the resource.</param>
        /// <return>Returns the Models.User response from the API call</return>
        public async Task<Models.User> CreateUsersAsync(
                string name,
                string username = null,
                string firstName = null,
                string lastName = null,
                string email = null,
                string url = null,
                string description = null,
                string nickname = null,
                string slug = null,
                List<string> roles = null,
                string password = null,
                List<string> capabilities = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/users");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "name", name },
                { "username", username },
                { "first_name", firstName },
                { "last_name", lastName },
                { "email", email },
                { "url", url },
                { "description", description },
                { "nickname", nickname },
                { "slug", slug },
                { "password", password }
            };
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("roles", roles));
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("capabilities", capabilities));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.User>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.User> response from the API call</return>
        public List<Models.User> GetUsers(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                List<string> roles = null,
                string slug = null)
        {
            Task<List<Models.User>> t = GetUsersAsync(context, page, perPage, search, exclude, include, order, morderby, roles, slug);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="roles">Optional parameter: Roles assigned to the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.User> response from the API call</return>
        public async Task<List<Models.User>> GetUsersAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                List<string> roles = null,
                string slug = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/users");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "exclude", exclude },
                { "include", include },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "roles", roles },
                { "slug", slug }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.User>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.Tag> response from the API call</return>
        public List<Models.Tag> GetTags(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string post = null,
                string slug = null)
        {
            Task<List<Models.Tag>> t = GetTagsAsync(context, page, perPage, search, exclude, include, order, morderby, post, slug);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.Tag> response from the API call</return>
        public async Task<List<Models.Tag>> GetTagsAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string post = null,
                string slug = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/tags");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "exclude", exclude },
                { "include", include },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "post", post },
                { "slug", slug }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Tag>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List categories
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="hideEmpty">Optional parameter: Whether to hide resources not assigned to any posts.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.Category> response from the API call</return>
        public List<Models.Category> GetCategories(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                bool? hideEmpty = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string post = null,
                string slug = null)
        {
            Task<List<Models.Category>> t = GetCategoriesAsync(context, page, perPage, search, hideEmpty, exclude, include, order, morderby, parent, post, slug);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List categories
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="hideEmpty">Optional parameter: Whether to hide resources not assigned to any posts.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <return>Returns the List<Models.Category> response from the API call</return>
        public async Task<List<Models.Category>> GetCategoriesAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                bool? hideEmpty = null,
                string exclude = null,
                string include = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string post = null,
                string slug = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/categories");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "hide_empty", hideEmpty },
                { "exclude", exclude },
                { "include", include },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "parent", parent },
                { "post", post },
                { "slug", slug }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Category>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Comment
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public Models.Comment CreateComments(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            Task<Models.Comment> t = CreateCommentsAsync(date, dateGmt, password, slug, status, title, author, commentStatus, pingStatus, altText, caption, description, post);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Comment
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public async Task<Models.Comment> CreateCommentsAsync(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/comments");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "title", title },
                { "author", author },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "alt_text", altText },
                { "caption", caption },
                { "description", description },
                { "post", post }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Comment>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Media
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public Models.Media CreateMedia(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            Task<Models.Media> t = CreateMediaAsync(date, dateGmt, password, slug, status, title, author, commentStatus, pingStatus, altText, caption, description, post);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Media
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public async Task<Models.Media> CreateMediaAsync(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/media");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "title", title },
                { "author", author },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "alt_text", altText },
                { "caption", caption },
                { "description", description },
                { "post", post }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Media>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public Models.Comment CreateCommentsById(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            Task<Models.Comment> t = CreateCommentsByIdAsync(id, date, dateGmt, password, slug, status, title, author, commentStatus, pingStatus, altText, caption, description, post);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Comment
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Comment response from the API call</return>
        public async Task<Models.Comment> CreateCommentsByIdAsync(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/comments/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "title", title },
                { "author", author },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "alt_text", altText },
                { "caption", caption },
                { "description", description },
                { "post", post }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Comment>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Comments
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="authorEmail">Optional parameter: Limit result set to that from a specific author email. Requires authorization.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="karma">Optional parameter: Limit result set to that of a particular comment karma. Requires authorization</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="type">Optional parameter: Limit result set to comments assigned a specific type. Requires authorization. Default comment</param>
        /// <return>Returns the List<Models.Comment> response from the API call</return>
        public List<Models.Comment> GetComments(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string authorEmail = null,
                string before = null,
                string exclude = null,
                string include = null,
                string karma = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string post = null,
                Models.StatusEnum? status = null,
                string type = null)
        {
            Task<List<Models.Comment>> t = GetCommentsAsync(context, page, perPage, search, after, author, authorExclude, authorEmail, before, exclude, include, karma, offset, order, morderby, parent, parentExclude, post, status, type);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Comments
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="authorEmail">Optional parameter: Limit result set to that from a specific author email. Requires authorization.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="karma">Optional parameter: Limit result set to that of a particular comment karma. Requires authorization</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="type">Optional parameter: Limit result set to comments assigned a specific type. Requires authorization. Default comment</param>
        /// <return>Returns the List<Models.Comment> response from the API call</return>
        public async Task<List<Models.Comment>> GetCommentsAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string authorEmail = null,
                string before = null,
                string exclude = null,
                string include = null,
                string karma = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string post = null,
                Models.StatusEnum? status = null,
                string type = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/comments");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "after", after },
                { "author", author },
                { "author_exclude", authorExclude },
                { "author_email", authorEmail },
                { "before", before },
                { "exclude", exclude },
                { "include", include },
                { "karma", karma },
                { "offset", offset },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "parent", parent },
                { "parent_exclude", parentExclude },
                { "post", post },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "type", type }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Comment>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public Models.Media CreateMediaById(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            Task<Models.Media> t = CreateMediaByIdAsync(id, date, dateGmt, password, slug, status, title, author, commentStatus, pingStatus, altText, caption, description, post);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Media
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="altText">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <param name="caption">Optional parameter: The caption for the resource.</param>
        /// <param name="description">Optional parameter: The description for the resource</param>
        /// <param name="post">Optional parameter: The id for the associated post of the resource.</param>
        /// <return>Returns the Models.Media response from the API call</return>
        public async Task<Models.Media> CreateMediaByIdAsync(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string author = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                string altText = null,
                string caption = null,
                string description = null,
                string post = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/media/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "title", title },
                { "author", author },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "alt_text", altText },
                { "caption", caption },
                { "description", description },
                { "post", post }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Media>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Media
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="mediaType">Optional parameter: Type of resource.</param>
        /// <param name="mimeType">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <return>Returns the List<Models.Media> response from the API call</return>
        public List<Models.Media> GetMedia(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                Models.MediaType58Enum? mediaType = null,
                string mimeType = null)
        {
            Task<List<Models.Media>> t = GetMediaAsync(context, page, perPage, search, after, author, authorExclude, before, exclude, include, offset, order, morderby, parent, parentExclude, slug, status, filter, mediaType, mimeType);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Media
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="mediaType">Optional parameter: Type of resource.</param>
        /// <param name="mimeType">Optional parameter: Alternative text to display when resource is not displayed.</param>
        /// <return>Returns the List<Models.Media> response from the API call</return>
        public async Task<List<Models.Media>> GetMediaAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                Models.MediaType58Enum? mediaType = null,
                string mimeType = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/media");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "after", after },
                { "author", author },
                { "author_exclude", authorExclude },
                { "before", before },
                { "exclude", exclude },
                { "include", include },
                { "offset", offset },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "parent", parent },
                { "parent_exclude", parentExclude },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "filter", filter },
                { "media_type", (mediaType.HasValue) ? MediaType58EnumHelper.ToValue(mediaType.Value) : null },
                { "mime_type", mimeType }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Media>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="template">Optional parameter: The theme file to use to display the object.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public Models.Page CreatePagesById(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                int? parent = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                int? menuOrder = null,
                int? template = null)
        {
            Task<Models.Page> t = CreatePagesByIdAsync(id, date, dateGmt, password, slug, status, parent, title, content, author, excerpt, featuredMedia, commentStatus, pingStatus, menuOrder, template);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Page
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="template">Optional parameter: The theme file to use to display the object.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public async Task<Models.Page> CreatePagesByIdAsync(
                string id,
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                int? parent = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                int? menuOrder = null,
                int? template = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/pages/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "parent", parent },
                { "title", title },
                { "content", content },
                { "author", author },
                { "excerpt", excerpt },
                { "featured_media", featuredMedia },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "menu_order", menuOrder },
                { "template", template }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Page>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Page
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="template">Optional parameter: The theme file to use to display the object.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public Models.Page CreatePages(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                int? parent = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                int? menuOrder = null,
                int? template = null)
        {
            Task<Models.Page> t = CreatePagesAsync(date, dateGmt, password, slug, status, parent, title, content, author, excerpt, featuredMedia, commentStatus, pingStatus, menuOrder, template);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Page
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="template">Optional parameter: The theme file to use to display the object.</param>
        /// <return>Returns the Models.Page response from the API call</return>
        public async Task<Models.Page> CreatePagesAsync(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                int? parent = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                int? menuOrder = null,
                int? template = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/pages");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "parent", parent },
                { "title", title },
                { "content", content },
                { "author", author },
                { "excerpt", excerpt },
                { "featured_media", featuredMedia },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "menu_order", menuOrder },
                { "template", template }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Page>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Pages
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <return>Returns the List<Models.Page> response from the API call</return>
        public List<Models.Page> GetPages(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                int? menuOrder = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null)
        {
            Task<List<Models.Page>> t = GetPagesAsync(context, page, perPage, search, after, author, authorExclude, before, exclude, include, menuOrder, offset, order, morderby, parent, parentExclude, slug, status, filter);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Pages
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="menuOrder">Optional parameter: The order of the object in relation to other object of its type.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="parent">Optional parameter: The id for the parent of the object.</param>
        /// <param name="parentExclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <return>Returns the List<Models.Page> response from the API call</return>
        public async Task<List<Models.Page>> GetPagesAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                int? menuOrder = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                int? parent = null,
                string parentExclude = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/pages");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "after", after },
                { "author", author },
                { "author_exclude", authorExclude },
                { "before", before },
                { "exclude", exclude },
                { "include", include },
                { "menu_order", menuOrder },
                { "offset", offset },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "parent", parent },
                { "parent_exclude", parentExclude },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "filter", filter }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Page>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public Models.Post PostsById(
                string id,
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            Task<Models.Post> t = PostsByIdAsync(id, context, page, perPage, search, after, author, authorExclude, before, exclude, include, offset, order, morderby, slug, status, filter, categories, tags);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update Single Post
        /// </summary>
        /// <param name="id">Required parameter: Id of object</param>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public async Task<Models.Post> PostsByIdAsync(
                string id,
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts/{id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "id", id }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "after", after },
                { "author", author },
                { "author_exclude", authorExclude },
                { "before", before },
                { "exclude", exclude },
                { "include", include },
                { "offset", offset },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "filter", filter }
            };
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("categories", categories));
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("tags", tags));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Post>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create Post
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="sticky">Optional parameter: Whether or not the object should be treated as sticky.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public Models.Post Posts(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                bool? sticky = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            Task<Models.Post> t = PostsAsync(date, dateGmt, password, slug, status, title, content, author, excerpt, featuredMedia, commentStatus, pingStatus, sticky, categories, tags);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create Post
        /// </summary>
        /// <param name="date">Optional parameter: The date the object was published, in the site's timezone.</param>
        /// <param name="dateGmt">Optional parameter: The date the object was published, as GMT.</param>
        /// <param name="password">Optional parameter: The A password to protect access to the post.</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="title">Optional parameter: The title for the object.</param>
        /// <param name="content">Optional parameter: The content for the object.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="excerpt">Optional parameter: The excerpt for the object</param>
        /// <param name="featuredMedia">Optional parameter: The id of the featured media for the object.</param>
        /// <param name="commentStatus">Optional parameter: Whether or not comments are open on the object</param>
        /// <param name="pingStatus">Optional parameter: Whether or not the object can be pinged.</param>
        /// <param name="sticky">Optional parameter: Whether or not the object should be treated as sticky.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the Models.Post response from the API call</return>
        public async Task<Models.Post> PostsAsync(
                DateTime? date = null,
                DateTime? dateGmt = null,
                string password = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string title = null,
                string content = null,
                string author = null,
                string excerpt = null,
                string featuredMedia = null,
                Models.CommentStatus34Enum? commentStatus = null,
                Models.PingStatus35Enum? pingStatus = null,
                bool? sticky = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("Authorization", string.Format("Bearer {0}", Configuration.OAuthAccessToken));

            //append form/field parameters
            var _fields = new Dictionary<string,object>()
            {
                { "date", (date.HasValue) ? date.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "date_gmt", (dateGmt.HasValue) ? dateGmt.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK") : null },
                { "password", password },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "title", title },
                { "content", content },
                { "author", author },
                { "excerpt", excerpt },
                { "featured_media", featuredMedia },
                { "comment_status", (commentStatus.HasValue) ? CommentStatus34EnumHelper.ToValue(commentStatus.Value) : null },
                { "ping_status", (pingStatus.HasValue) ? PingStatus35EnumHelper.ToValue(pingStatus.Value) : null },
                { "sticky", sticky }
            };
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("categories", categories));
            _fields.Add(APIHelper.PrepareFormFieldsFromObject("tags", tags));

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Post>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// List Posts
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the List<Models.Post> response from the API call</return>
        public List<Models.Post> GetPosts(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            Task<List<Models.Post>> t = GetPostsAsync(context, page, perPage, search, after, author, authorExclude, before, exclude, include, offset, order, morderby, slug, status, filter, categories, tags);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// List Posts
        /// </summary>
        /// <param name="context">Optional parameter: Scope under which the request is made; determines fields present in response.</param>
        /// <param name="page">Optional parameter: Current page of the collection. Default 1</param>
        /// <param name="perPage">Optional parameter: Maximum number of items to be returned in result set. Default 10</param>
        /// <param name="search">Optional parameter: Limit results to those matching a string.</param>
        /// <param name="after">Optional parameter: Limit response to resources published after a given ISO8601 compliant date.</param>
        /// <param name="author">Optional parameter: Limit result set to posts assigned to specific authors.</param>
        /// <param name="authorExclude">Optional parameter: Ensure result set excludes posts assigned to specific authors.</param>
        /// <param name="before">Optional parameter: Limit response to resources published before a given ISO8601 compliant date.</param>
        /// <param name="exclude">Optional parameter: Ensure result set excludes specific ids.</param>
        /// <param name="include">Optional parameter: Ensure result set includes specific ids.</param>
        /// <param name="offset">Optional parameter: Offset the result set by a specific number of items.</param>
        /// <param name="order">Optional parameter: Order sort attribute ascending or descending. Default desc</param>
        /// <param name="morderby">Optional parameter: Sort collection by object attribute. Default date</param>
        /// <param name="slug">Optional parameter: Limit result set to posts with a specific slug.</param>
        /// <param name="status">Optional parameter: Limit result set to posts assigned a specific status.Default publish</param>
        /// <param name="filter">Optional parameter: Use WP Query arguments to modify the response; private query vars require appropriate authorization.</param>
        /// <param name="categories">Optional parameter: Limit result set to all items that have the specified term assigned in the categories taxonomy.</param>
        /// <param name="tags">Optional parameter: Limit result set to all items that have the specified term assigned in the tags taxonomy.</param>
        /// <return>Returns the List<Models.Post> response from the API call</return>
        public async Task<List<Models.Post>> GetPostsAsync(
                Models.ContextEnum? context = null,
                int? page = null,
                int? perPage = null,
                string search = null,
                string after = null,
                string author = null,
                string authorExclude = null,
                string before = null,
                string exclude = null,
                string include = null,
                string offset = null,
                Models.OrderEnum? order = null,
                Models.OrderbyEnum? morderby = null,
                string slug = null,
                Models.StatusEnum? status = null,
                string filter = null,
                List<string> categories = null,
                List<string> tags = null)
        {
            //the base uri for api requestss
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/posts");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "context", (context.HasValue) ? ContextEnumHelper.ToValue(context.Value) : null },
                { "page", page },
                { "per_page", perPage },
                { "search", search },
                { "after", after },
                { "author", author },
                { "author_exclude", authorExclude },
                { "before", before },
                { "exclude", exclude },
                { "include", include },
                { "offset", offset },
                { "order", (order.HasValue) ? OrderEnumHelper.ToValue(order.Value) : null },
                { "orderby", (morderby.HasValue) ? OrderbyEnumHelper.ToValue(morderby.Value) : null },
                { "slug", slug },
                { "status", (status.HasValue) ? StatusEnumHelper.ToValue(status.Value) : null },
                { "filter", filter },
                { "categories", categories },
                { "tags", tags }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Post>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

    }
} 